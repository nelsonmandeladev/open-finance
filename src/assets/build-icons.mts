import * as path from "node:path";
import fsExtra from "fs-extra";
import { glob } from "glob";
import { parse } from "node-html-parser";

const currentWorkingDir = process.cwd();

const inputDir = path.join(currentWorkingDir, "src", "assets", "icons");
const baseAssetDir = path.join(currentWorkingDir, "src", "assets");

const inputDirRelative = path.resolve(currentWorkingDir, inputDir);

const outputDir = path.join(currentWorkingDir, "public", "icons", "svg");

await fsExtra.ensureDir(outputDir);

const files = glob
  .sync("**/*.svg", {
    cwd: inputDir,
  })
  .sort((a, b) => a.localeCompare(b));

const shouldVerboseLog = process.argv.includes("--log=verbose");

const logVerbose = shouldVerboseLog ? console.log : () => {};

if (files.length === 0) {
  console.log(`No files in ${inputDirRelative}`);
} else {
  await generateIconFiles();
}

async function generateIconFiles() {
  const allIconsFilePath = path.join(outputDir, "generals.svg");
  const typesOutputFilePath = path.join(baseAssetDir, "index.d.ts");

  const currentSprite = await fsExtra
    .readFile(allIconsFilePath, "utf-8")
    .catch(() => "");
  const currentType = await fsExtra
    .readFile(typesOutputFilePath, "utf-8")
    .catch(() => "");

  const iconNames = files.map((file) => iconName(file));

  const spriteUpToDate = iconNames.every((name) =>
    currentSprite.includes(`id=${name}`),
  );
  const typeUpToDate = iconNames.every((name) =>
    currentType.includes(`${name}`),
  );

  if (spriteUpToDate && typeUpToDate) {
    logVerbose("Icons are up to date");
    return;
  }

  logVerbose(`Generating sprite for the ${inputDirRelative}`);

  const spriteChanged = await generateSvgSprite({
    files,
    inputDir,
    outputDir: allIconsFilePath,
  });

  for (const file of files) {
    logVerbose(`âœ… `, file);
  }

  logVerbose(`Saved to ${path.relative(currentWorkingDir, allIconsFilePath)}`);

  const stringifiedIconsName = iconNames.map((name) => JSON.stringify(name));

  const typeOutputContent = `// This file is generated automatically base on the icons files in the /assets/icons folder
        declare type IconType = \t| ${stringifiedIconsName.join("\n\t| ")}
    `;

  const typesChanged = await writeIfChanged(
    typesOutputFilePath,
    typeOutputContent,
  );

  logVerbose(
    `Manifest saved to ${path.relative(currentWorkingDir, typesOutputFilePath)}`,
  );

  const readmeChanged = await writeIfChanged(
    path.join(baseAssetDir, "README.md"),
    `# Icons
            This is assets management directory to store the icons that will be auto generated.
        `,
  );

  if (spriteChanged || typesChanged || readmeChanged) {
    console.log(`Generated ${files.length} icons`);
  }
}

function iconName(file: string) {
  return file.replace(/\.svg$/, "");
}

async function generateSvgSprite({
  files,
  inputDir,
  outputDir,
}: {
  files: string[];
  inputDir: string;
  outputDir: string;
}) {
  const symbol = await Promise.all(
    files.map(async (file) => {
      const input = await fsExtra.readFile(path.join(inputDir, file), "utf-8");

      const root = parse(input);

      const svg = root.querySelector("svg");

      if (!svg) {
        throw new Error("No Svg element found");
      }

      svg.tagName = "symbol";
      svg.setAttribute("id", iconName(file));
      svg.removeAttribute("xmlns");
      svg.removeAttribute("xmlns:xlink");
      svg.removeAttribute("version");
      svg.removeAttribute("width");
      svg.removeAttribute("height");
      svg.removeAttribute("fill");

      const paths = svg.querySelectorAll("path");
      for (const path of paths) {
        path.removeAttribute("fill");
        path.removeAttribute("stroke");
      }

      return svg.toString().trim();
    }),
  );

  const output = [
    `<?xml version="1.0" encoding="utf-8"?>`,
    `<!-- This file is generated by yarn build:icons -->`,
    `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="0" height="0">`,
    `<defs>`,
    ...symbol,
    `</defs>`,
    `</svg>`,
    "", // trailing newline
  ].join("\n");

  return writeIfChanged(outputDir, output);
}

async function writeIfChanged(filePath: string, newContent: string) {
  const currentContent = await fsExtra
    .readFile(filePath, "utf-8")
    .catch(() => "");
  if (currentContent === newContent) {
    return false;
  }

  await fsExtra.writeFile(filePath, newContent, "utf-8");
}
